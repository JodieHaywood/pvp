<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Haskell PVP FAQ</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <nav id="menu" class="clearfix">
          <div class="item left logo-container clearfix"><img class="logo" src="http://www.haskell.org/static/img/logo.png" alt="Haskell Logo"><span class="logo-text">PVP.haskell.org</span></div>
          <div class="item link left">[<a href="../">Specification</a>]</div> &nbsp;
          <div class="item link left">[<a href="../faq">FAQ</a>]</div>
        </nav>
         
        <div id="container">
            <h1 id="haskell-package-versioning-policy-faq-draft">Haskell Package Versioning Policy FAQ <sup><sup>[DRAFT]</sup></sup><a href="#haskell-package-versioning-policy-faq-draft" class="anchor">🔗</a></h1>
<p>This FAQ is intended answer questions related to aspects commonly being brought up in discussions involving the Haskell <a href="http://pvp.haskell.org">PVP</a>.</p>
<p>If you have a question not addressed by the FAQ entries, feel free to post your question in the <a href="https://github.com/haskell/pvp/issues">PVP Issue Tracker</a>.</p>
<h2 id="semver">SemVer<a href="#semver" class="anchor">🔗</a></h2>
<h3 id="how-does-the-pvp-relate-to-semantic-versioning-semver">How does the PVP relate to <a href="http://semver.org">Semantic Versioning (SemVer)</a>?<a href="#how-does-the-pvp-relate-to-semantic-versioning-semver" class="anchor">🔗</a></h3>
<p>Historically, the <a href="http://semver.org">SemVer specification</a> saw the light of day in late 2009, whereas the first incarnation of the PVP was already conceived <a href="https://mail.haskell.org/pipermail/haskell/2006-November/018762.html">3 years earlier in late 2006</a>.</p>
<p>The basic goals of SemVer and PVP are very similiar, namely, to <strong>provide a formal specification for version numbers to make it possible to specify version bounds for dependency management</strong> (c.f. <a href="http://semver.org/#why-use-semantic-versioning">Why Use Semantic Versioning?</a>).</p>
<p>The most apparent somewhat superficial difference between SemVer and the PVP is which components of the version number are interpreted as major, minor, and patch-level numerals:</p>
<ul>
<li>PVP: <em>MAJOR.MAJOR.MINOR.PATCH</em></li>
<li>SemVer: <em>MAJOR.MINOR.PATCH</em></li>
</ul>
<p>While having a 2-part major component may confuse people used to SemVer, it provides an additional dimension for communicating API changes:</p>
<ul>
<li><p>One popular way is to use the first component of the major version to denote “epochs” of APIs (c.f. Edward Kmett’s packages) and allowing development (with major version increments) to continue independently in different epochs. This allows to avoid suffixing packages names with numbers to denote different epochs (e.g. <code>base2-1.0</code>, <code>base3-1.0</code>, <code>base4-1.0</code>).</p></li>
<li><p>A different way to see the 2-part major version component is to allow for nuanced signaling of large vs. not-so-large backward incompatible changes.</p></li>
<li><p>Yet another way is to use the first component for marketing purposes, e.g. to increment to “1.0” when a package is considered mature.</p></li>
</ul>
<p>Another important difference between SemVer and PVP is that the PVP doesn’t distinguish between <code>0.x.y</code> and <code>1.x.y</code>. SemVer considers the major version zero for initial development and allows the API to change without requiring major version increment. The PVP, however, <em>does not</em> provide for such an exception. This is for historical reasons because Cabal provides a <code>Stability</code>-field in its package meta-data for providing this kind of signalling; Unfortunately, this facility isn’t used consistently and so can’t be relied upon.</p>
<p>Under the PVP, packages with a zero major version provide the same contractual guarantees as versions released with a non-zero major version.</p>
<p>Also, while SemVer allows for appending version tags and/or build metadata (e.g. <code>1.0.0-alpha+git.5114f85</code>), the PVP does not regulate nor support such additional information in version numbers.</p>
<p>Last but not least, SemVer is mostly language agnostic, while the PVP is designed with Haskell and the needs of the Hackage/Cabal ecosystem in mind, and describes the rules in terms of Haskell’s specific language facilities (module system, name resolution, typeclass instances).</p>
<h3 id="can-we-switch-to-using-the-more-widely-established-semver-standard-instead-of-the-less-known-pvp-on-hackage">Can we switch to using the more widely established SemVer standard instead of the less known PVP on Hackage?<a href="#can-we-switch-to-using-the-more-widely-established-semver-standard-instead-of-the-less-known-pvp-on-hackage" class="anchor">🔗</a></h3>
<p>While this would avoid the initial confusion for new users coming from ecosystems where SemVer has become the standard, it would come at a significant cost for the existing Hackage ecosystem.</p>
<p>Most notably, users and tooling would need to know which dependencies follow SemVer and which are still using the PVP scheme.</p>
<p>If it’s to be allowed for a package to switch from PVP to SemVer, one would also need to keep track of the version at which the transition occurred. Also, packages which are still using PVP-style upper bounds would miss out on backward compatible updates during the transition, since a PVP major version upper bound is just a minor version upper bound in the SemVer representation.</p>
<h2 id="upper-bounds">Upper bounds<a href="#upper-bounds" class="anchor">🔗</a></h2>
<h3 id="defining-upper-bounds-requires-to-know-the-future-as-you-cant-know-whether-a-not-yet-released-future-version-will-contain-a-breaking-change.">Defining upper bounds requires to know the future, as you can’t know whether a not yet released future version will contain a breaking change.<a href="#defining-upper-bounds-requires-to-know-the-future-as-you-cant-know-whether-a-not-yet-released-future-version-will-contain-a-breaking-change." class="anchor">🔗</a></h3>
<p>Of course, the PVP doesn’t provide you with a way to know <em>for sure</em> when compatibility will break; however, the PVP tells you a <em>least upper bound up to which your package is guaranteed</em> (under certain conditions) to remain compatible.</p>
<p>Without the PVP contract, you’d be left with no choice but to constraint your package to versions of dependencies for which you have empirical “known to work” evidence for (or complete control over).</p>
<h3 id="upper-bounds-can-be-inferred-by-running-build-bots-to-determine-when-breaking-changes-have-been-introduced-in-dependencies.">Upper bounds can be inferred by running build bots to determine when breaking changes have been introduced in dependencies.<a href="#upper-bounds-can-be-inferred-by-running-build-bots-to-determine-when-breaking-changes-have-been-introduced-in-dependencies." class="anchor">🔗</a></h3>
<p>This assumes that compile-success is equivalent to semantic correctness. While it’s true that a compile failure implies that a breakage has occurred, the inverse is not true in general.</p>
<p>There’s been already a couple of incidents (see next Q) when popular packages changed their semantics without changing their type-signature and thereby caused problems in packages which didn’t have proper PVP-mandated upper bounds in place.</p>
<p>Therefore leaving off upper bounds under the assumption that breakages will show in form of build-failures is a dangerous erroneous belief, as it can result in hard to detect/debug silent failures.</p>
<h3 id="what-are-some-real-world-examples-of-packages-causing-breakage-due-to-semantic-changes">What are some real-world examples of packages causing breakage due to semantic changes?<a href="#what-are-some-real-world-examples-of-packages-causing-breakage-due-to-semantic-changes" class="anchor">🔗</a></h3>
<p>In the major version <code>aeson-0.10</code>, the serialization of <code>Maybe</code>-values was deliberately changed in an incompatible way which caused packages not declaring an upper bound to be caught off guard. In <code>aeson-0.11</code> this was changed yet again.</p>
<p>In <code>deepseq-1.4</code>, the default method implementation of <code>rnf</code> was changed from reducing to WHNF to generically deriving a NF-evaluating traversal. Code which assumed a default of <code>rnf x = seq x ()</code> could break if the new <code>rnf</code> implementation resulted in suddenly traversing a data structure which wasn’t meant to be traversed beyond WHNF (like e.g. cyclic. datastructures).</p>
<h3 id="what-is-the-intended-meaning-of-upper-bounds-is-it-not-known-to-be-compatible-or-rather-known-not-to-be-compatible">What is the intended meaning of upper bounds; is it “<em>not known</em> to be compatible” or rather “<em>known not</em> to be compatible”?<a href="#what-is-the-intended-meaning-of-upper-bounds-is-it-not-known-to-be-compatible-or-rather-known-not-to-be-compatible" class="anchor">🔗</a></h3>
<p>Note how confusingly similiar the two variants sound; it’s just a subtle difference in word order. Also note the use of the term “compatible” which is intended to emphasize <em>semantic API compatibility</em>, rather than merely succesfull compilation (I.e. there’s no “it compiles, it works” property which holds in general for Haskell… yet).</p>
<p>The central idea of the PVP (and SemVer) is to serve as a contract to communicate API compatibility guarantees (NB: <em>not</em> to predict breakage!). To this end, the version number semantics are encoded in sophisticated rules for when exactly to increment the various components.</p>
<p>As such, it makes little sense to interpret the PVP mandated upper bounds as the stronger “known not to be compatible” (i.e. having evidence of incompatibility), as then one would almost never be able to declare upper bounds in the first place. This would greatly reduce the value of the PVP as well as make it difficult to justify the effort of following the complex formal rules for assigning version numbers in the first place.</p>
<p>Consequently, the PVP mandated upper bounds are intended to denote “not known (yet) to be compatible” bounds, i.e. the least upper bounds up to which API compatibility is guaranteed by the PVP contract. This may not be an ultimate guarantee, but without such upper bounds, there’s no guarantee <em>at all</em> the next released version won’t cause breakage.</p>
<p>Or put differently, the goal of PVP mandated upper bounds is to be conservative, but in the most liberal way possible.</p>
<h3 id="packages-like-base-almost-never-break-my-code-on-major-version-increments-does-this-make-predicted-upper-bounds-less-useful">Packages like <code>base</code> almost never break my code on major version increments; does this make predicted upper bounds less useful?<a href="#packages-like-base-almost-never-break-my-code-on-major-version-increments-does-this-make-predicted-upper-bounds-less-useful" class="anchor">🔗</a></h3>
<p><code>base</code> is an example for a large package with a huge exposed API, which is tracked as a whole by a single version number. Often, API consumers tend to use only a small fraction of the exposed API surface, and in the case of <code>base</code> this most often a very stable subset. However, <code>base</code> being so large typically changes in backward incompatible ways with each major GHC release, even though most programs are not affected.</p>
<p>So the problem here is that big monolithic packages are rather disadvantageous in the context of semantic versioning, whose goal is to formalize version numbers to the point of making predicting upper bounds feasible at all.</p>
<p>However, this doesn’t detract from the usefulness of upper bounds; this just means that more cost is shifted from the single API provider to its many API consumers for such big monolithic packages.</p>
<p>Ideally, such big packages can be deconstructed into smaller modular packages which each focus on separate concerns. This way version numbers become more expressive as they cover a smaller API surface, and the risk for API consumers of running into a major version update because of changes in totally unrelated parts is reduced accordingly.</p>
<p>But this comes at a cost: Maintaining a carefully crafted set of focused packages is more costly to the maintainer compared to maintaining a single monolithic package, which comes at the expense of API consumers as they need to review major version updates more frequently for potential incompatibilities.</p>
<h2 id="hackage-stackage">Hackage &amp; Stackage<a href="#hackage-stackage" class="anchor">🔗</a></h2>
<h3 id="my-package-is-in-stackage-and-people-can-use-it-just-fine-do-i-need-to-follow-the-pvp-and-put-in-version-bounds">My package is in Stackage and people can use it just fine; do I need to follow the PVP and put in version bounds?<a href="#my-package-is-in-stackage-and-people-can-use-it-just-fine-do-i-need-to-follow-the-pvp-and-put-in-version-bounds" class="anchor">🔗</a></h3>
<p>Yes, packages uploaded to Hackage (which is a pre-requisite for being included in Stackage) are expected to honor the PVP.</p>
<p>There are course also 3rd party distribution/curation systems, such as Stackage or Linux distributions, which create distributions from subsets of Hackage’s repository. But the existence of such external systems does not relieve package authors from the responsibility to follow the PVP when publishing on Hackage.</p>
<p>Hackage is designed to be a self-contained package repository for consumption by <code>cabal</code> which relies on constraint-solving for computing install plans. Without accurate version bounds, your package will result in poor user experience with <code>cabal</code> which won’t have accurate enough information to operate properly, as well as run into problems such as Haddock failing to regenerate documentation due to degrading install-plans.</p>
<h2 id="applying-the-pvp">Applying the PVP<a href="#applying-the-pvp" class="anchor">🔗</a></h2>
<h3 id="my-package-doesnt-provide-any-api-does-the-pvp-apply-to-executable-only-packages">My Package doesn’t provide any API; does the PVP apply to executable-only packages?<a href="#my-package-doesnt-provide-any-api-does-the-pvp-apply-to-executable-only-packages" class="anchor">🔗</a></h3>
<p>Even if a package doesn’t expose any public API, the guidelines for API consumers which describe how to declare version constraints for tracking dependencies still apply.</p>
<p>In some cases, the rules for API providers may apply as well, like for executables such as <code>alex</code> or <code>happy</code> which generate code, and especially when such packages are meant to be tracked as dependencies in <code>build-tools</code>.</p>
<h3 id="what-implications-does-the-pvp-have-when-re-exporting-api-elements">What implications does the PVP have when re-exporting API elements?<a href="#what-implications-does-the-pvp-have-when-re-exporting-api-elements" class="anchor">🔗</a></h3>
<p>The PVP is a contract between the API provider which declares a package version, and any API consumer depending on that package.</p>
<p>It’s the responsibility of the provider to guarantee that the exposed API is a function of the declared version, and in particular does not depend on the versions of its transitive dependencies, as this defy the purpose of the PVP.</p>
<p>To avoid such issues, it’s best to avoid re-exporting API elements from other packages when it’s avoidable. In cases where it’s essential to re-export API elements, try to reduce the risk by being very defensive and control exactly what is re-exported (e.g. avoid unconstrained module-level re-exports), and make sure to use tight version bounds.</p>
<p>A related issue is conditional APIs (see next item).</p>
<h3 id="what-implications-does-the-pvp-have-for-conditional-apis">What implications does the PVP have for conditional APIs?<a href="#what-implications-does-the-pvp-have-for-conditional-apis" class="anchor">🔗</a></h3>
<p>As already stated in the previous item, it’s important for a package version to uniquely identify the exposed API in order to fulfill its purpose as a semantic version. So ideally, the exposed API shall be a function of <em>only</em> its package version.</p>
<p>However, conditional APIs, cause the exposed API to weaken the relationship to its version. So packages can’t rely on the package providing an API to be accurately described by only its version, but rather need to track all other variables which may have an effect on the relied upon API.</p>
<p>This obviously increases the risk for errors, due to the combinatorial increase of configurations one needs to consider, and should therefore be avoided.</p>
<p>However, it is reasonable to deviate from this recommendation, when the API conditionality is practically impossible to observe by API consumers. An example is when API features are conditional on compiler features which consumers are only able to use of if they depend on that same compiler feature as well. A common example are API features conditional on <code>Generic</code> support:</p>
<p>The <code>NFData</code> class is basically defined as</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">NFData</span> a <span class="kw">where</span>
<span class="ot">    rnf ::</span> a <span class="ot">-&gt;</span> ()
<span class="ot">#if HAVE_GENERICS</span>
    default<span class="ot"> rnf ::</span> (<span class="dt">Generic</span> a, <span class="dt">GNFData</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> ()
    rnf <span class="fu">=</span> grnf <span class="fu">.</span> from
<span class="ot">#endif</span></code></pre></div>
<p>Consequently, <code>rnf</code>’s default implementation is conditional on the currently available compiler features.</p>
<p>However, it’s practically impossible to write consumer code which is able to observe (i.e. break due to) this specific kind of API conditionally, as you’d need to have access to the <code>Generic</code> class and be able to define instances for it in the first place, before being able to make use of (and thus observe) the default implementation of <code>rnf</code>.</p>
        </div>

        <footer>
          <p>If you'd like suggest changes, please <a href="https://github.com/haskell/pvp/issues">open an issue on GitHub</a>.</p>
        </footer>
    </body>
</html>
