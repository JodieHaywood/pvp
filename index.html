<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Haskell PVP Specification</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
    </head>
    <body>
        <nav id="menu" class="clearfix">
          <div class="item left logo-container clearfix"><img class="logo" src="http://www.haskell.org/static/img/logo.png" alt="Haskell Logo"><span class="logo-text">PVP.haskell.org</span></div>
          <div class="item link left">[<a href="./">Specification</a>]</div> &nbsp;
          <div class="item link left">[<a href="./faq">FAQ</a>]</div>
        </nav>
         
        <div id="container">
            <h1 id="haskell-package-versioning-policy">Haskell Package Versioning Policy<a href="#haskell-package-versioning-policy" class="anchor">🔗</a></h1>
<h2 id="rationale">Rationale<a href="#rationale" class="anchor">🔗</a></h2>
<p>The goal of a versioning system is to inform clients of a package of changes to that package that might affect them, and to provide a way for clients to specify a particular version or range of versions of a dependency that they are compatible with.</p>
<p><a href="http://haskell.org/cabal">Cabal</a> provides the raw materials for versioning: it allows packages to specify their own version, and it allows dependencies that specify which versions of the dependent package are acceptable. Cabal will select dependencies based on the constraints.</p>
<p>What is missing from this picture is a <em>policy</em> that tells the library developer how to set their version numbers, and tells a client how to write a dependency that means their package will not try to compile against an incompatible dependency. For some time there has been an informal policy in use in the Haskell community, but it became clear that we were running into trouble with incorrectly-specified dependencies and unbuildable packages, so this page is an attempt to formalize the policy.</p>
<h2 id="version-numbers">Version numbers<a href="#version-numbers" class="anchor">🔗</a></h2>
<p>The key words &quot;MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a>.</p>
<p>A package version number <strong>SHOULD</strong> have the form <em>A.B.C</em>, and <strong>MAY</strong> optionally have any number of additional components, for example 2.1.0.4 (in this case, <em>A</em>=2, <em>B</em>=1, <em>C=0</em>). This policy defines the meaning of the first three components <em>A-C</em>, the other components can be used in any way the package maintainer sees fit.</p>
<p>Version number ordering is already defined by Cabal as the lexicographic ordering of the components. For example, 2.0.1 &gt; 1.3.2, and 2.0.1.0 &gt; 2.0.1. (The <code>Data.Version.Version</code> type and its <code>Ord</code> instance embody this ordering).</p>
<p><em>A.B</em> is known as the <em>major</em> version number, and <em>C</em> the <em>minor</em> version number. When a package is updated, the following rules govern how the version number must change relative to the previous version:</p>
<ol style="list-style-type: decimal">
<li><p><em>Breaking change</em>. If any entity was removed, or the types of any entities or the definitions of datatypes or classes were changed, or orphan instances were added or any instances were removed, then the new <em>A.B</em> <strong>MUST</strong> be greater than the previous <em>A.B</em>. Note that modifying imports or depending on a newer version of another package may cause extra orphan instances to be exported and thus force a major version change.</p></li>
<li><p><em>Non-breaking change</em>. Otherwise, if only new bindings, types, classes, non-orphan instances or modules (but see below) were added to the interface, then <em>A.B</em> <strong>MAY</strong> remain the same but the new <em>C</em> <strong>MUST</strong> be greater than the old <em>C</em>. Note that modifying imports or depending on a newer version of another package may cause extra non-orphan instances to be exported and thus force a minor version change.</p></li>
<li><p><em>Other changes</em>. Otherwise, e.g. if change consist only of corrected documentation, non-visible change to allow different dependency range etc. <em>A.B.C</em> <strong>MAY</strong> remain the same (other version components may change).</p></li>
<li><p><em>Client specification</em>. Hence <em>A.B.C</em> uniquely identifies the API. A client that wants to specify that they depend on a particular version of the API can specify a particular <em>A.B.C</em> and be sure of getting that API only. For example, <code>build-depends: mypkg &gt;= 2.1.1 &amp;&amp; &lt; 2.1.2</code>.</p></li>
<li><p><em>Backwards compatible client specification</em>. Often a package maintainer wants to add to an API without breaking backwards compatibility, and in that case they can follow the rules of point 2, and increase only <em>C</em>. A client <strong>MAY</strong> specify that they are <a href="https://wiki.haskell.org/Import_modules_properly">insensitive to additions to the API</a> by allowing a range of <em>C</em> values, e.g. <code>build-depends: base &gt;= 2.1.1 &amp;&amp; &lt; 2.2</code>.</p></li>
<li><p><em>Client defines orphan instance</em>. If a package defines an orphan instance, it <strong>MUST</strong> depend on the minor version of the packages that define the data type and the type class to be backwards compatible. For example, <code>build-depends: mypkg &gt;= 2.1.1 &amp;&amp; &lt; 2.1.2</code>.</p></li>
<li><p><em>Deprecation</em>. Deprecated entities (via a <code>DEPRECATED</code> pragma) <em>SHOULD</em> be counted as removed for the purposes of upgrading the API, because packages that use <code>-Werror</code> will be broken by the deprecation. In other words the new <em>A.B</em> <strong>SHOULD</strong> be greater than the previous <em>A.B</em>.</p></li>
<li><p><em>Adding new modules</em>. Adding new modules might cause an unavoidable name collision in dependent code. However, this is usually pretty unlikely, especially if you keep to your own namespace, so only an increase of the minor version number is required, in other words <em>A.B</em> <strong>MAY</strong> remain the same the new <em>C</em> <strong>MUST</strong> be greater than the old <em>C</em>. If, however, your added module name is taken from another package (e.g. when <code>network-bytestring</code> was merged into <code>network</code>) or is quite general (<code>Data.Set</code> or something similar) then the version increase <strong>SHOULD</strong> be major.</p></li>
</ol>
<h2 id="special-situations">Special situations<a href="#special-situations" class="anchor">🔗</a></h2>
<h3 id="leaking-instances">Leaking instances<a href="#leaking-instances" class="anchor">🔗</a></h3>
<p>There is a case where addition or removal of an instance in a package that the user doesn't depend on directly can still lead to compilation failures. Consider these three packages:</p>
<p>Package A:</p>
<pre class="haskell"><code>module PackageA where

class Monad m =&gt; MonadLogger m
instance MonadLogger IO</code></pre>
<p>Package B, depends on package A:</p>
<pre class="haskell"><code>module PackageB where

import PackageA

f :: MonadLogger m =&gt; Int -&gt; m String
f = return . show</code></pre>
<p>Package C, depends on package B:</p>
<pre class="haskell"><code>module Package C where

import PackageB

main :: IO ()
main = f 5 &gt;&gt;= print</code></pre>
<p>Now consider this scenario:</p>
<ol style="list-style-type: decimal">
<li>Package A removes the <code class="haskell">IO</code> instance and gets its major version number bumped, as required by the PVP.</li>
<li>Package B, which can still work with the old and new version of package A, changes its dependency on package A to allow for both versions. Package B only gets a patch-level bump.</li>
<li>Package C might or might not compile, depending on which patch-level version of package B is used.</li>
</ol>
<p>The PVP could require that package B must bump its major version number as it now (re-)exports one fewer instances. This will however require more frequent version bumps in the whole ecosystem. As a pragmatic solution, for now the PVP doesn't required a major version bump in this case and instead leaves it to package C to add a dependency on package A to handle this situation.</p>
<h3 id="version-tags">Version tags<a href="#version-tags" class="anchor">🔗</a></h3>
<p>The components of the version number <strong>MUST</strong> be numbers! Historically Cabal supported version numbers with string tags at the end, e.g. <code>1.0-beta</code> This proved not to work well because the ordering for tags was not well defined. Version tags are <a href="https://github.com/haskell/cabal/issues/890">no longer supported</a> and mostly ignored, however some tools will fail in some circumstances if they encounter them.</p>
<p>This can sometimes trip you up if you accidentally stumble into using the deprecated tags syntax without realising it, for example a version number with a date like <code>1.0.2014-01-27</code> would be interpreted as the version <code>1.0.2014</code> with tags <code>01</code> and <code>27</code>.</p>
<h2 id="decision-tree">Decision Tree<a href="#decision-tree" class="anchor">🔗</a></h2>
<p>The (incomplete!) decision tree summarises the PVP rules in a concise form</p>
<div class="figure">
<img src="pvp-decision-tree.svg" />

</div>
<h2 id="dependencies-in-cabal">Dependencies in Cabal<a href="#dependencies-in-cabal" class="anchor">🔗</a></h2>
<p>When publishing a Cabal package, you <strong>SHALL</strong> ensure that your dependencies in the <code>build-depends</code> field are accurate. This means specifying not only lower bounds, but also upper bounds on every dependency.</p>
<p>At some point in the future, Hackage may refuse to accept packages that do not follow this convention. The aim is that before this happens, we will put in place tool support that makes it easier to follow the convention and less painful when dependencies are updated.</p>
<p>To minimize breakage when new package versions are released, you can use dependencies that are insensitive to minor version changes (e.g. <code>foo &gt;= 1.2.1 &amp;&amp; &lt; 1.3</code>). However, note that this approach is slightly risky: when a package exports more things than before, there is a chance that your code will fail to compile due to new name-clash errors. The risk from new name clashes may be small, but you are on the safe side if you <a href="https://wiki.haskell.org/Import_modules_properly">import identifiers explicitly or using qualification</a>.</p>
<h2 id="version-syntax">Version syntax<a href="#version-syntax" class="anchor">🔗</a></h2>
<p>Since Cabal 1.6, you can specify an exact API version according to this policy with the special syntax <code>package == 1.1.4.*</code> or an API version up to additions with <code>package == 1.1.*</code>. The former translates into <code>package &gt;= 1.1.4 &amp;&amp; &lt; 1.1.5</code>, for example - notice that 1.1.4 <em>is</em> included, rather than just including 1.1.4.0.</p>
<h2 id="tools">Tools<a href="#tools" class="anchor">🔗</a></h2>
<ul>
<li>script to check for API changes in gtk2hs: <a href="http://code.haskell.org/gtk2hs/tools/apidiff/" class="uri">http://code.haskell.org/gtk2hs/tools/apidiff/</a></li>
<li><a href="http://hackage.haskell.org/package/precis">precis</a> - a simple tool for a first approximation of package API differences, see the <a href="http://www.haskell.org/pipermail/haskell-cafe/2010-April/077023.html">announcement</a></li>
<li><a href="http://hackage.haskell.org/package/check-pvp">check-pvp</a> is a program that checks for consistency between package dependencies and import style.</li>
</ul>
<h2 id="related">Related<a href="#related" class="anchor">🔗</a></h2>
<ul>
<li>Sven Moritz Hallberg, &quot;<a href="https://wiki.haskell.org/The_Monad.Reader/Issue2/EternalCompatibilityInTheory">Eternal compatibility in theory</a>,&quot; <a href="https://wiki.haskell.org/The_Monad.Reader">The Monad.Reader</a>, <a href="https://wiki.haskell.org/The_Monad.Reader/Issue2">Issue 2</a></li>
<li><a href="http://semver.org/">Semantic Versioning</a> is similar, but allows for version tags and defines how tags affect the ordering.</li>
</ul>
        </div>

        <footer>
          <p>If you'd like suggest changes, please <a href="https://github.com/haskell/pvp/issues">open an issue on GitHub</a>.</p>
        </footer>
    </body>
</html>
