<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Package Versioning Policy â€“ </title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  
  /* General styling */
  
  h1,h2,h3,h4,h5,h6 {
  font-family: Raleway,Helvetica,Arial,sans-serif;
  text-align: left;
  }
  
  body {
    font-family: Source Sans Pro,Helvetica,Arial,sans-serif;
    font-size: 16px;
    text-align: justify;
    line-height: 1.5;
  
    margin: 0;
    background-color: #FDFDFF;
  }
  
  code {
    background-color: #f4f4f4;
    padding: 0 2px 0 2px;
    border-radius: 2px;
  }
  
  figure {
    text-align: center;
    margin: 0;
  }
  
  h1 { font-size: 32px; font-weight: bold; border-bottom: 1px solid black; }
  h2 { font-size: 24px; font-weight: bold; border-bottom: 1px solid black; }
  h3 { font-size: 18px; font-weight: bold; border-bottom: 1px solid black; }
  
  li {
    margin-bottom: 0.7em;
  }
  
  a { text-decoration: none; color: #428bca; }
  a:hover { text-decoration: underline; cursor: pointer; }
  
  .clearfix:after {
    content: "";
    display: table;
    clear: both;
  }
  
  div.sourceCode {
  border: 0px solid gray;
  border-radius: 5px;
  background-color: #f4f4f4;
  padding: 0 1em;
  }
  
  /* Menu */
  
  #menu {
    background: linear-gradient(to right,#150e1a 0%,#22172a 100%);
    padding: 10px 10px 10px 20px;
  }
  
  #menu .item {
    font-size: 20px;
    margin-right: 10px;
    color: #d1cddc;
    max-height: 43px;
  }
  
  #menu .item.left {
    float: left;
  }
  #menu .item.right {
    float: right;
  }
  
  #menu .item a {
    font-size: 20px;
    color: #d1cddc;
  }
  #menu .item a:hover {
    color: white;
  }
  
  #menu .logo-container {
    margin-right: 50px;
  }
  
  #menu .logo {
    height: 43px;
    width: 64px;
    float: left;
  }
  
  #menu .logo-text {
    float: left;
  font-size: 20px;
   font-weight: bold;
    margin-left: 10px;
    margin-top: 9px;
  }
  
  #menu .item.link {
    margin: 8px 20px 0 0;
  }
  
  /* Main container */
  
  #container {
    width: 800px;
    margin: auto;
    margin-top: 20px;
  }
  
  footer {
    font-size: 10px;
    font-weight: lighter;
    text-align: right;
    width: 800px;
    margin: auto;
    margin-top: 20px;
  }
  
  /* Pages */
  
  .page {
    display: none;
    width: 1200px;
    margin: auto;
  }
  .page:after {
    content: "";
    display: table;
    clear: both;
  }
  
  /* Left column */
  
  .leftcol {
    float: left;
    padding: 0;
    width: 750px;
  }
  .leftcol:after {
    content: "";
    display: table;
    clear: both;
  }
  
  /* Left split */
  .leftcol.col-2 .leftcol-2-left {
    width: 370px;
    float: left;
  }
  .leftcol.col-2 .leftcol-2-right {
    width: 370px;
    float: right;
  }
  
  /* Right column */
  
  .rightcol {
    float: right;
    padding: 0;
    width: 425px;
  }
  
  /* Main content */
  
  .main-header {
    margin: 0;
  }
  .main-header-subtext {
    margin-bottom: 20px;
  }
    
  </style>
</head>
<body>

<nav id="menu" class="clearfix">
  <div class="item left logo-container clearfix"><img class="logo" src="http://www.haskell.org/static/img/logo.png" alt="Haskell Logo"><span class="logo-text">PVP.haskell.org</span></div>
  <div class="item link left"><a href="//pvp.haskell.org/">PVP Specification</a></div>
</nav>

<div id="container">
<h1 id="package-versioning-policy">Package versioning policy</h1>
<h2 id="rationale">Rationale</h2>
<p>The goal of a versioning system is to inform clients of a package of changes to that package that might affect them, and to provide a way for clients to specify a particular version or range of versions of a dependency that they are compatible with.</p>
<p><a href="http://haskell.org/cabal">Cabal</a> provides the raw materials for versioning: it allows packages to specify their own version, and it allows dependencies that specify which versions of the dependent package are acceptable. Cabal will select dependencies based on the constraints.</p>
<p>What is missing from this picture is a <em>policy</em> that tells the library developer how to set their version numbers, and tells a client how to write a dependency that means their package will not try to compile against an incompatible dependency. For some time there has been an informal policy in use in the Haskell community, but it became clear that we were running into trouble with incorrectly-specified dependencies and unbuildable packages, so this page is an attempt to formalize the policy.</p>
<h2 id="version-numbers">Version numbers</h2>
<p>A package version number should have the form <em>A.B.C</em>, and may optionally have any number of additional components, for example 2.1.0.4 (in this case, <em>A</em>=2, <em>B</em>=1, <em>C=0</em>). This policy defines the meaning of the first three components <em>A-C</em>, the other components can be used in any way the package maintainer sees fit.</p>
<p>Version number ordering is already defined by Cabal as the lexicographic ordering of the components. For example, 2.0.1 &gt; 1.3.2, and 2.0.1.0 &gt; 2.0.1. (The <code>Data.Version.Version</code> type and its <code>Ord</code> instance embody this ordering).</p>
<p><em>A.B</em> is known as the <em>major</em> version number, and <em>C</em> the <em>minor</em> version number. When a package is updated, the following rules govern how the version number must change relative to the previous version:</p>
<ol type="1">
<li>If any entity was removed, or the types of any entities or the definitions of datatypes or classes were changed, or <a href="https://wiki.haskell.org/Orphan_instance">orphan instances</a> were added or any instances were removed, then the new <em>A.B</em> must be greater than the previous <em>A.B</em>. Note that modifying imports or depending on a newer version of another package may cause extra orphan instances to be exported and thus force a major version change.</li>
<li>Otherwise, if only new bindings, types, classes, non-orphan instances or modules (but see below) were added to the interface, then <em>A.B</em> may remain the same but the new <em>C</em> must be greater than the old <em>C</em>. Note that modifying imports or depending on a newer version of another package may cause extra non-orphan instances to be exported and thus force a minor version change.</li>
<li>Otherwise, <em>A.B.C</em> may remain the same (other version components may change).</li>
</ol>
<p>Hence <em>A.B.C</em> uniquely identifies the API. A client that wants to specify that they depend on a particular version of the API can specify a particular <em>A.B.C</em> and be sure of getting that API only. For example, <code>build-depends: mypkg &gt;= 2.1.1 &amp;&amp; &lt; 2.1.2</code>.</p>
<p>Often a package maintainer wants to add to an API without breaking backwards compatibility, and in that case they can follow the rules of point 2, and increase only <em>C</em>. A client can specify that they are <a href="https://wiki.haskell.org/Import_modules_properly">insensitive to additions to the API</a> by allowing a range of <em>C</em> values, e.g. <code>build-depends: base &gt;= 2.1.1 &amp;&amp; &lt; 2.2</code>.</p>
<p>If a package defines an orphan instance, it must depend on the minor version of the packages that define the data type and the type class to be backwards compatible. For example, <code>build-depends: mypkg &gt;= 2.1.1 &amp;&amp; &lt; 2.1.2</code>.</p>
<h3 id="deprecation">Deprecation</h3>
<p>Deprecated entities (via <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#warning-and-deprecated-pragmas">a <code>DEPRECATED</code> pragma</a>) should probably be counted as removed for the purposes of upgrading the API, because packages that use <code>-Werror</code> will be broken by the deprecation.</p>
<h3 id="adding-new-modules">Adding new modules</h3>
<p>Adding new modules might cause an unavoidable name collision in dependent code. However, this is usually pretty unlikely, especially if you keep to your own namespace, so only an increase of the minor version number is required. If, however, your added module name is taken from another package (e.g. when <code>network-bytestring</code> was merged into <code>network</code>) or is quite general (<code>Data.Set</code> or something similar) then the version increase should be major.</p>
<h3 id="leaking-instances">Leaking instances</h3>
<p>There is a case where addition or removal of an instance in a package that the user doesn't depend on directly can still lead to compilation failures. Consider these three packages:</p>
<p>Package A:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">PackageA</span> <span class="kw">where</span>

<span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadLogger</span> m
<span class="kw">instance</span> <span class="dt">MonadLogger</span> <span class="dt">IO</span></code></pre></div>
<p>Package B, depends on package A:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">PackageB</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">PackageA</span>

<span class="ot">f ::</span> <span class="dt">MonadLogger</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">String</span>
f <span class="fu">=</span> return <span class="fu">.</span> show</code></pre></div>
<p>Package C, depends on package B:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Package</span> <span class="dt">C</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">PackageB</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> f <span class="dv">5</span> <span class="fu">&gt;&gt;=</span> print</code></pre></div>
<p>Now consider this scenario:</p>
<ol type="1">
<li>Package A removes the <code class="sourceCode haskell"><span class="dt">IO</span></code> instance and gets its major version number bumped, as required by the PVP.</li>
<li>Package B, which can still work with the old and new version of package A, changes its dependency on package A to allow for both versions. Package B only gets a patch-level bump.</li>
<li>Package C might or might not compile, depending on which patch-level version of package B is used.</li>
</ol>
<p>The PVP could required that package B must bump its major version number as it now (re-)exports one fewer instances. This will however require more frequent version bumps in the whole ecosystem. As a pragmatic solution, for now the PVP doesn't required a major version bump in this case and instead leaves it to package C to add a dependency on package A to handle this situation.</p>
<h3 id="version-tags">Version tags</h3>
<p>The components of the version number must be numbers! Historically Cabal supported version numbers with string tags at the end, e.g. <code>1.0-beta</code> This proved not to work well because the ordering for tags was not well defined. Version tags are <a href="https://github.com/haskell/cabal/issues/890">no longer supported</a> and mostly ignored, however some tools will fail in some circumstances if they encounter them.</p>
<p>This can sometimes trip you up if you accidentally stumble into using the deprecated tags syntax without realising it, for example a version number with a date like <code>1.0.2014-01-27</code> would be interpreted as the version <code>1.0.2014</code> with tags <code>01</code> and <code>27</code>.</p>
<h2 id="decision-tree">Decision Tree</h2>
<p>The (incomplete!) decision tree summarises the PVP rules in a concise form</p>
<figure>
<img src="pvp-decision-tree.svg" />
</figure>
<h2 id="dependencies-in-cabal">Dependencies in Cabal</h2>
<p>When publishing a Cabal package, you should ensure that your dependencies in the <code>build-depends</code> field are accurate. This means specifying not only lower bounds, but also upper bounds on every dependency.</p>
<p>At some point in the future, Hackage may refuse to accept packages that do not follow this convention. The aim is that before this happens, we will put in place tool support that makes it easier to follow the convention and less painful when dependencies are updated.</p>
<p>To minimize breakage when new package versions are released, you can use dependencies that are insensitive to minor version changes (e.g. <code>foo &gt;= 1.2.1 &amp;&amp; &lt; 1.3</code>). However, note that this approach is slightly risky: when a package exports more things than before, there is a chance that your code will fail to compile due to new name-clash errors. The risk from new name clashes may be small, but you are on the safe side if you <a href="https://wiki.haskell.org/Import_modules_properly">import identifiers explicitly or using qualification</a>.</p>
<h2 id="version-syntax">Version syntax</h2>
<p>Since Cabal 1.6, you can specify an exact API version according to this policy with the special syntax <code>package == 1.1.4.*</code> or an API version up to additions with <code>package == 1.1.*</code>. The former translates into <code>package &gt;= 1.1.4 &amp;&amp; &lt; 1.1.5</code>, for example - notice that 1.1.4 <em>is</em> included, rather than just including 1.1.4.0.</p>
<h2 id="tools">Tools</h2>
<ul>
<li>script to check for API changes in gtk2hs: <a href="http://code.haskell.org/gtk2hs/tools/apidiff/" class="uri">http://code.haskell.org/gtk2hs/tools/apidiff/</a></li>
<li><a href="http://hackage.haskell.org/package/precis">precis</a> - a simple tool for a first approximation of package API differences, see the <a href="http://www.haskell.org/pipermail/haskell-cafe/2010-April/077023.html">announcement</a></li>
<li><a href="http://hackage.haskell.org/package/check-pvp">check-pvp</a> is a program that checks for consistency between package dependencies and import style.</li>
</ul>
<h2 id="related">Related</h2>
<ul>
<li>Sven Moritz Hallberg, &quot;<a href="https://wiki.haskell.org/The_Monad.Reader/Issue2/EternalCompatibilityInTheory">Eternal compatibility in theory</a>,&quot; <a href="https://wiki.haskell.org/The_Monad.Reader">The Monad.Reader</a>, <a href="https://wiki.haskell.org/The_Monad.Reader/Issue2">Issue 2</a></li>
<li><a href="http://semver.org/">Semantic Versioning</a> is similar, but allows for version tags and defines how tags affect the ordering.</li>
</ul>
</div>


<footer>
  <p>If you'd like suggest changes, please <a href="https://github.com/haskell/pvp/issues">open an issue on GitHub</a>.</p>
</footer>
</body>
</html>
